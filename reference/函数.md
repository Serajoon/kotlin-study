
# 函数

## 函数声明

在Kotlin中用关键字**fun**声明函数：
``` kotlin
fun double(x: Int): Int {
    return 2 * x
}
```

## 函数用法

通过传统的方法调用函数
``` kotlin
val result = double(2)
```


通过.调用成员函数
``` kotlin
Sample().foo() // 创建Sample类的实例调用foo方法
```

### 参数

函数参数是用Pascal符号定义的，**name:type**，每个参数必须指明类型

``` kotlin
fun powerOf(number: Int, exponent: Int) {
...
}
```

### 默认参数

函数参数可以设置默认值,当参数被忽略时会使用默认值。这样相比其他语言可以减少重载。

``` kotlin
fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size){
...
}
```
默认值通过类型后面的 **=** 及给出的值来定义。

Overriding methods always use the same default parameter values as the base method.
When overriding a method with default parameters values, the default parameter values must be omitted from the signature:

``` kotlin
open class A {
    open fun foo(i: Int = 10) { ... }
}

class B : A() {
    override fun foo(i: Int) { ... }  // no default value allowed
}
```

如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用命名参数调用该函数来使用：

``` kotlin
fun foo(bar: Int = 0, baz: Int) { /* ... */ }

foo(baz = 1) // 使用默认值bar=0
```

### 命名参数

在调用函数时参数可以命名。这对于那种有大量参数的函数是很方便的.

``` kotlin
fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean = false,
             wordSeparator: Char = ' ') {
...
}
```

我们可以使用默认参数

``` kotlin
reformat(str)
```

当调用非默认参数时就需要像下面这样使用，看起来很不直观

``` kotlin
reformat(str, true, true, false, '_')
```

使用命名参数可以让代码可读性更强

``` kotlin
reformat(str,
    normalizeCase = true,
    upperCaseFirstLetter = true,
    divideByCamelHumps = false,
    wordSeparator = '_'
)
```

如果不需要全部参数的话可以这样
``` kotlin
reformat(str, wordSeparator = '_')
```

当一个调用混用位置参数与命名参数时，所有位置参数都要放在第一个命名参数之前，即命名参数要放到。例如，允许调用 f(1, y = 2) 但不允许 f(x = 1, 2)。
```kotlin
fun f(x: Int, y: Int = 2) {
    println(x+y)
}
f(y=3,1) //编译错误
```

### 不带返回值的参数

如果函数不会返回任何有用值，那么他的返回类型就是 Unit .Unit 是一个只有唯一值Unit的类型.这个值并不需要被直接返回:

``` kotlin
fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello ${name}")
    else
        println("Hi there!")
    // `return Unit` or `return` is optional
}
```

Unit 返回值也可以省略，比如下面这样：

``` kotlin
fun printHello(name: String?) {
    ...
}
```

### 单表达式函数

当函数只返回单个表达式时，大括号可以省略并在 **=** 后面定义函数体:

``` kotlin
fun double(x: Int): Int = x * 2
```

在编译器可以推断出返回值类型的时候,返回值的类型可以省略:

``` kotlin
fun double(x: Int) = x * 2
```

### 明确返回值类型
 
下面的例子中必须有明确返回类型,除非他是返回 Unit类型的值,Kotlin 并不会对函数体重的返回类型进行推断,因为函数体中可能有复杂的控制流,他的返回类型未必对读者可见(甚至对编译器而言也有可能是不可见的)：


### 变长参数

函数的参数(通常是最后一个参数)可以用 **vararg** 修饰符进行标记：

``` kotlin
fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts是一个数组
        result.add(t)
    return result
}
```
标记后,允许给函数传递可变长度的参数：

``` kotlin
val list = asList(1, 2, 3)
```
只有一个参数可以被标注为**vararg**。
假如vararg并不是列表中的最后一个参数,那么后面的参数需要通过命名参数语法进行传值,再或者如果这个参数是函数类型,就需要通过lambda法则.


当调用变长参数的函数时，我们可以一个一个的传递参数，比如 asList(1, 2, 3)，或者我们要传递一个 array 的内容给函数，我们就可以使用 * 前缀操作符：

```kotlin
val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
```

### 中缀符号

函数可以使用 **infix**定义。中缀函数必须满足下列条件

* 必须是成员函数或者扩展函数
* 必须是单参数函数，且使用**infix**修饰函数
* 参数不能是可变参数(vararg)而且参数不能有默认值

``` kotlin
infix fun String.shl(x: String): String {
    //使用this代表调用者的值
    //改功能相当于为String类型扩展了功能
    return this+x
}
//使用
"a" shl "b"
"a".shl("b")
```

请注意，中缀函数总是要求指定接收者与参数。当使用中缀表示法在当前接收者上调用方法时，需要显式使用 this；不能像常规方法调用那样省略。这是确保非模糊解析所必需的。

```kotlin
class MyStringCollection {
    infix fun add(s: String) { /* ... */ }
    
    fun build() {
        this add "abc"   // 正确
        add("abc")       // 正确
        add "abc"        // 必须指定接受者
    }
}
```


## 函数作用域

在 Kotlin 中函数可以在文件顶层声明，这意味着你不需要像一些语言如 Java、C# 或 Scala 那样创建一个类来保存一个函数。此外除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。

### 局部函数

Kotlin 支持局部函数，即一个函数在另一个函数内部：

``` kotlin
fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: Set<Vertex>) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v, visited)
    }

    dfs(graph.vertices[0], HashSet())
}
```

局部函数可以访问外部函数（即闭包）的局部变量，所以在上例中，visited 可以是局部变量：


``` kotlin
fun dfs(graph: Graph) {
    val visited = HashSet<Vertex>()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v)
    }

    dfs(graph.vertices[0])
}
```

### 成员函数

成员函数是在类(class)或对象内部(object)定义的函数：


``` kotlin
class Sample() {
    fun foo() { print("Foo") }
}
```

成员函数以点表示法调用：

``` kotlin
Sample().foo() // 创建类Sample实例并调用foo
```

For more information on classes and overriding members see [Classes](classes.html) and [Inheritance](classes.html#inheritance).

## 泛型函数

函数可以有泛型参数，通过在函数名前使用尖括号指定：

``` kotlin
fun <T> singletonList(item: T): List<T> {
    // ...
}
```

## 内联函数

Inline functions are explained [here](inline-functions.html).

## 扩展函数


## 高阶函数和 Lambda 表达式



## 尾递归函数

Kotlin 支持一种称为尾递归的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 tailrec 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：

``` kotlin
tailrec fun findFixPoint(x: Double = 1.0): Double
        = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))
```

这段代码计算余弦的不动点（fixpoint of cosine），这是一个数学常数。 它只是重复地从 1.0 开始调用 Math.cos，直到结果不再改变，产生0.7390851332151607的结果。最终代码相当于这种更传统风格的代码：

``` kotlin
private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (x == y) return x
        x = y
    }
}
```
要符合 tailrec 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前尾部递归只在 JVM 后端中支持。



